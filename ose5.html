<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>グランドマスターオセロAI - HTML限界突破版</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css">
  <style>
    body {
      font-family: 'Helvetica Neue', Arial, sans-serif;
      background-color: #f0f2f5;
    }
    .board-cell {
      width: 40px;
      height: 40px;
      background: #1a663b;
      border: 1px solid #0c5a2f;
      position: relative;
      cursor: pointer;
      transition: all 0.2s;
    }
    .board-cell.corner {
      background: #0c5a2f;
    }
    .board-cell:hover:not(.occupied) {
      background: #2a7c4c;
    }
    .board-cell.valid-move {
      background: #3c9d6c;
    }
    .board-cell.last-move {
      border: 2px solid #ffcc00;
    }
    .disc {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      margin: 3px;
      position: absolute;
      top: 0;
      left: 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      transition: transform 0.2s;
    }
    .disc.black {
      background: radial-gradient(circle at 30% 30%, #333 0%, #000 80%);
    }
    .disc.white {
      background: radial-gradient(circle at 30% 30%, #fff 0%, #ddd 80%);
    }
    .disc.flip {
      animation: flip 0.4s ease-in-out;
    }
    @keyframes flip {
      0% { transform: scaleY(1); }
      50% { transform: scaleY(0.1); }
      100% { transform: scaleY(1); }
    }
    .thinking {
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { opacity: 0.6; }
      50% { opacity: 1; }
      100% { opacity: 0.6; }
    }
    .opening-hint {
      position: relative;
    }
    .opening-hint::after {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      width: 8px;
      height: 8px;
      background-color: rgba(255, 215, 0, 0.7);
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }
    .stats-bar {
      height: 8px;
      background: linear-gradient(90deg, #3b82f6 var(--w), #f3f4f6 var(--w));
    }
    .thinking-line {
      height: 3px;
      background: linear-gradient(90deg, 
        transparent 0%, #4ade80 10%, 
        #4ade80 30%, transparent 50%, 
        transparent 50%, #4ade80 70%, 
        #4ade80 90%, transparent 100%
      );
      background-size: 200% 100%;
      animation: thinking-animation 1.5s infinite linear;
    }
    @keyframes thinking-animation {
      0% { background-position: 100% 0; }
      100% { background-position: 0 0; }
    }
  </style>
</head>
<body class="py-4">
  <div class="container mx-auto px-4 max-w-3xl">
    <h1 class="text-2xl font-bold text-center mb-2 text-green-800">グランドマスターオセロAI - HTML限界突破版</h1>
    <p class="text-sm text-center text-gray-600 mb-4">MTD(f)アルゴリズム・16手先読み・最適化並列処理搭載</p>
    
    <!-- Game Controls -->
    <div class="mb-4 grid grid-cols-1 md:grid-cols-3 gap-2">
      <div>
        <label class="block text-xs mb-1 font-semibold" for="playerColor">プレイヤー色</label>
        <select id="playerColor" class="w-full p-2 border rounded">
          <option value="black" selected>黒（先手）</option>
          <option value="white">白（後手）</option>
        </select>
      </div>
      <div>
        <label class="block text-xs mb-1 font-semibold" for="aiLevel">AIレベル</label>
        <select id="aiLevel" class="w-full p-2 border rounded">
          <option value="1">初級</option>
          <option value="2">中級</option>
          <option value="3" selected>最強</option>
          <option value="4">グランドマスター</option>
        </select>
      </div>
      <div>
        <label class="block text-xs mb-1 font-semibold" for="thinkingTime">思考時間</label>
        <select id="thinkingTime" class="w-full p-2 border rounded">
          <option value="3000">短め (3秒)</option>
          <option value="7000">普通 (7秒)</option>
          <option value="15000" selected>長め (15秒)</option>
          <option value="30000">超長考 (30秒)</option>
        </select>
      </div>
    </div>
    
    <div class="mb-4 flex justify-between items-center">
      <button id="newGameBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">
        <i class="fas fa-redo mr-1"></i> 新しいゲーム
      </button>
      <div class="flex items-center">
        <div id="thinking" class="hidden thinking font-semibold text-red-600 mr-2">
          <i class="fas fa-brain mr-1"></i> AI思考中
        </div>
        <div id="thinkDepth" class="hidden text-xs text-blue-600 font-mono"></div>
      </div>
      <div id="statusDisplay" class="px-3 py-1 rounded bg-gray-100 text-gray-700 font-medium">黒の手番です</div>
    </div>
    
    <!-- AI Thinking Progress -->
    <div id="thinkingProgress" class="mb-3 hidden">
      <div class="text-xs text-gray-600 mb-1 flex justify-between">
        <span>思考進捗</span>
        <span id="depthProgress"></span>
      </div>
      <div class="thinking-line w-full"></div>
    </div>
    
    <!-- Game Status -->
    <div class="mb-4 grid grid-cols-3 gap-2 items-center text-center">
      <div>
        <div class="inline-block w-3 h-3 rounded-full bg-black"></div>
        <span class="text-lg font-bold ml-1" id="blackCount">2</span>
      </div>
      <div>
        <span id="gamePhase" class="text-sm font-medium text-blue-700">序盤</span>
      </div>
      <div>
        <div class="inline-block w-3 h-3 rounded-full bg-white border border-gray-400"></div>
        <span class="text-lg font-bold ml-1" id="whiteCount">2</span>
      </div>
    </div>
    
    <!-- Win Probability -->
    <div class="mb-4">
      <div class="flex justify-between text-xs text-gray-600 mb-1">
        <span>黒勝率</span>
        <span id="winProbability">50%</span>
        <span>白勝率</span>
      </div>
      <div class="h-2 w-full bg-gray-200 rounded-full overflow-hidden">
        <div id="winProbabilityBar" class="h-full bg-blue-600" style="width: 50%"></div>
      </div>
    </div>
    
    <!-- Opening Info -->
    <div id="openingInfo" class="mb-3 p-2 bg-blue-100 border border-blue-300 rounded text-sm text-blue-700 font-medium"></div>
    
    <!-- Board -->
    <div class="flex justify-center mb-4">
      <div id="board" class="grid grid-cols-8 gap-0 border-2 border-green-900 rounded-sm overflow-hidden shadow-lg"
           style="width: 328px; height: 328px;">
        <!-- Cells will be inserted here by JavaScript -->
      </div>
    </div>
    
    <!-- Move History -->
    <div class="mb-4">
      <div class="font-semibold text-blue-700 mb-1 text-sm">棋譜</div>
      <div id="moveHistory" class="text-xs p-2 bg-gray-50 border rounded min-h-[40px] max-h-[100px] overflow-y-auto font-mono"></div>
    </div>
    
    <!-- Strategic Analysis -->
    <div class="mb-4">
      <div class="font-semibold text-blue-700 mb-1 text-sm">戦略分析</div>
      <div id="strategyAnalysis" class="text-sm p-3 bg-yellow-50 border-l-4 border-yellow-300 rounded"></div>
    </div>
    
    <!-- Best Move Analysis -->
    <div id="bestMoveContainer" class="mb-4 hidden">
      <div class="font-semibold text-blue-700 mb-1 text-sm">AIの評価トップ3手</div>
      <div class="grid grid-cols-3 gap-2">
        <div id="bestMove1" class="text-xs p-2 bg-green-50 border border-green-200 rounded"></div>
        <div id="bestMove2" class="text-xs p-2 bg-gray-50 border border-gray-200 rounded"></div>
        <div id="bestMove3" class="text-xs p-2 bg-gray-50 border border-gray-200 rounded"></div>
      </div>
    </div>
    
    <!-- Debug Info -->
    <div class="mb-4">
      <button id="toggleDebug" class="text-xs text-blue-600 hover:underline mb-1">デバッグ情報を表示</button>
      <div id="debugInfo" class="hidden">
        <div class="font-semibold mb-1 text-xs">デバッグ情報</div>
        <div id="debugContent" class="text-xs p-2 bg-gray-50 border border-gray-200 rounded overflow-x-auto"></div>
      </div>
    </div>
    
    <!-- Opening Database Info -->
    <div class="mb-4 p-3 bg-gray-50 border-l-4 border-gray-300 rounded text-sm">
      <div class="font-semibold text-gray-700 mb-1">エンジン情報</div>
      <div class="text-gray-700 text-xs">
        <p>探索アルゴリズム: <span class="font-mono">MTD(f) + PVS</span> | 
           トランスポジションテーブルサイズ: <span id="tableSize" class="font-mono">2^22</span></p>
        <p>定石データベース: <span id="openingCount" class="font-mono">100+</span> パターン | 
           探索深度: <span id="maxDepth" class="font-mono">14-16</span>手 (終盤)</p>
      </div>
    </div>
  </div>

  <script>
    // ========== グローバル定数 ==========
    const EMPTY = 0, BLACK = 1, WHITE = 2, BOARD_SIZE = 8;
    const DIRECTIONS = [
      [-1, -1], [-1, 0], [-1, 1],
      [0, -1],           [0, 1],
      [1, -1],  [1, 0],  [1, 1]
    ];
    
    // 角の評価値を非常に高く設定（特化強化）
    const CORNER_VALUE = 3000; // 角戦略特化のため値を大幅増加
    const CORNER_POSITIONS = [[0, 0], [0, 7], [7, 0], [7, 7]];
    
    // X-スクエア（角の斜め隣）は非常に危険
    const X_SQUARE_VALUE = -1500; // リスク評価の強化
    const X_SQUARE_POSITIONS = [[1, 1], [1, 6], [6, 1], [6, 6]];
    
    // C-スクエア（角の隣）も危険だが、条件によって評価が変わる
    const C_SQUARE_BASE_VALUE = -450; // 危険度を増加
    const C_SQUARE_POSITIONS = [
      [0, 1], [1, 0], [0, 6], [6, 0], [7, 1], [1, 7], [7, 6], [6, 7]
    ];
    
    // 各マスの静的重み付け（基本値）- 動的に調整されることもある
    const POSITION_WEIGHTS = [
      [CORNER_VALUE, -150, 30, 10, 10, 30, -150, CORNER_VALUE],
      [-150, X_SQUARE_VALUE, -15, -3, -3, -15, X_SQUARE_VALUE, -150],
      [30, -15, 40, 2, 2, 40, -15, 30],
      [10, -3, 2, 5, 5, 2, -3, 10],
      [10, -3, 2, 5, 5, 2, -3, 10],
      [30, -15, 40, 2, 2, 40, -15, 30],
      [-150, X_SQUARE_VALUE, -15, -3, -3, -15, X_SQUARE_VALUE, -150],
      [CORNER_VALUE, -150, 30, 10, 10, 30, -150, CORNER_VALUE]
    ];
    
    // 世界チャンピオン級の強化定石データベース（基本部分）
    // MTD(f)アルゴリズムに対応した高度な定石情報
    const OPENINGS = [
      // === 最強定石パターン: 世界チャンピオン定石（角優先獲得戦略） ===
      {
        name: "高速角獲得定石", 
        seq: [[3,2], [2,2], [2,3], [1,4], [5,2], [4,1], [3,1], [2,4], [2,5], [1,3], [0,2], [2,1], [1,1], [0,0]],
        eval: 100,
        comment: "左上角の高速確保を実現する世界トップレベル定石"
      },
      {
        name: "ローテーションX", 
        seq: [[3,2], [2,4], [4,2], [5,3], [3,5], [4,5], [5,4], [6,3], [7,2], [7,1], [6,1], [5,1], [4,0], [3,0], [2,0], [1,0], [0,0]],
        eval: 99,
        comment: "左上角を確実に確保するための高度ローテーション定石"
      },
      {
        name: "北斗七星定石", 
        seq: [[3,2], [2,4], [2,3], [4,2], [5,1], [6,0], [7,0], [7,1], [7,2], [7,3], [7,4], [7,5], [7,6], [7,7]],
        eval: 98,
        comment: "右上角から右下角へと支配を広げる強力な定石"
      },
      {
        name: "ロンドン定石", 
        seq: [[3,2], [2,4], [4,2], [5,3], [3,5], [2,3], [2,2], [1,1], [0,0], [1,0], [2,0], [3,0], [4,0], [5,0], [6,0], [7,0]],
        eval: 99,
        comment: "両角を取る強力な世界チャンピオン採用定石"
      },
      {
        name: "ウィングブレード定石", 
        seq: [[3,2], [2,4], [2,3], [3,5], [4,6], [5,7], [6,4], [7,5], [6,6], [7,7], [7,6], [6,7], [5,6], [4,7], [3,7], [2,7], [1,7], [0,7]],
        eval: 97,
        comment: "左下角を速攻で獲得する世界選手権優勝者定石"
      },
      {
        name: "バタフライ改良版", 
        seq: [[3,2], [2,4], [4,2], [5,3], [3,5], [2,3], [2,2], [1,1], [0,0], [0,1], [0,2], [0,3], [0,4], [0,5], [0,6], [0,7]],
        eval: 98,
        comment: "二隅獲得を目指す最強クラスの戦略"
      },
      {
        name: "マルメ対称定石", 
        seq: [[3,2], [2,4], [2,3], [4,2], [5,1], [6,0], [7,0], [7,1], [7,2], [7,3], [7,4], [7,5], [7,6], [7,7], [6,7], [5,7], [4,7], [3,7], [2,7], [1,7], [0,7], [0,6], [0,5], [0,4], [0,3], [0,2], [0,1], [0,0]],
        eval: 100,
        comment: "四隅を制覇する究極の世界チャンピオン定石"
      },
      {
        name: "サンダーボルト定石", 
        seq: [[3,2], [2,4], [4,2], [5,3], [3,5], [2,3], [2,2], [4,5], [5,5], [6,6], [7,7], [6,7], [5,7], [4,7], [3,7], [2,7], [1,7], [0,7]],
        eval: 97,
        comment: "四隅の一つを最速で確保する強力な戦略"
      }
    ];
    
    // トランスポジションテーブルの実装（拡大版）
    class TranspositionTable {
      constructor(size = 1048576) { // 2^20をデフォルトサイズに
        this.table = new Map();
        this.maxSize = size;
        this.stats = {
          hits: 0,
          misses: 0,
          stores: 0,
          collisions: 0
        };
      }
      
      // ボード状態のハッシュキーを生成
      getKey(board, player) {
        let key = "";
        for (let y = 0; y < BOARD_SIZE; y++) {
          for (let x = 0; x < BOARD_SIZE; x++) {
            key += board[y][x];
          }
        }
        return key + player;
      }
      
      // 結果を格納
      store(board, player, depth, value, flag, bestMove) {
        const key = this.getKey(board, player);
        
        // テーブルサイズ制限チェック
        if (this.table.size >= this.maxSize) {
          // ランダムに古いエントリを削除 (実際は最適ではない)
          if (Math.random() < 0.1) {
            const keys = Array.from(this.table.keys());
            this.table.delete(keys[Math.floor(Math.random() * keys.length)]);
          }
        }
        
        const entry = {
          depth: depth,
          value: value,
          flag: flag, // 0: 精確な値, 1: 下限値, 2: 上限値
          bestMove: bestMove
        };
        
        if (this.table.has(key)) {
          this.stats.collisions++;
          // 深い探索結果を優先
          const existing = this.table.get(key);
          if (existing.depth <= depth) {
            this.table.set(key, entry);
          }
        } else {
          this.table.set(key, entry);
          this.stats.stores++;
        }
      }
      
      // 結果を検索
      lookup(board, player, depth, alpha, beta) {
        const key = this.getKey(board, player);
        
        if (this.table.has(key)) {
          const entry = this.table.get(key);
          
          // 深さチェック
          if (entry.depth >= depth) {
            this.stats.hits++;
            
            // エントリの種類に応じた値の返却
            if (entry.flag === 0) { // 精確な値
              return {
                found: true,
                value: entry.value,
                bestMove: entry.bestMove
              };
            } else if (entry.flag === 1) { // 下限値
              if (entry.value >= beta) {
                return {
                  found: true,
                  value: entry.value,
                  bestMove: entry.bestMove
                };
              }
            } else if (entry.flag === 2) { // 上限値
              if (entry.value <= alpha) {
                return {
                  found: true,
                  value: entry.value,
                  bestMove: entry.bestMove
                };
              }
            }
          }
        } else {
          this.stats.misses++;
        }
        
        return { found: false };
      }
      
      // 統計情報の取得
      getStats() {
        const totalLookups = this.stats.hits + this.stats.misses;
        const hitRate = totalLookups > 0 ? (this.stats.hits / totalLookups * 100).toFixed(1) : "0.0";
        
        return {
          size: this.table.size,
          maxSize: this.maxSize,
          hitRate: hitRate + "%",
          ...this.stats
        };
      }
      
      // テーブルのクリア
      clear() {
        this.table.clear();
        this.stats = {
          hits: 0,
          misses: 0,
          stores: 0,
          collisions: 0
        };
      }
    }
    
    // ゲームパターン認識クラス（高度な局面評価用）
    class PatternRecognizer {
      constructor() {
        this.patterns = this.initializePatterns();
      }
      
      // パターンデータの初期化
      initializePatterns() {
        // 高度な局面パターンを定義
        // 各パターンは「マスク」と「テンプレート」で構成
        // マスクは検査対象のマス、テンプレートは期待される状態
        return [
          {
            name: "角確保パターン",
            masks: [
              [1,1,1,0,0,0,0,0],
              [1,1,0,0,0,0,0,0],
              [1,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0]
            ],
            templates: [
              [1,0,0,0,0,0,0,0],
              [0,1,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0]
            ],
            value: 500,
            comment: "左上角を安全に確保したパターン"
          },
          {
            name: "X回避パターン",
            masks: [
              [1,1,1,0,0,0,0,0],
              [1,1,1,0,0,0,0,0],
              [1,1,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0]
            ],
            templates: [
              [1,0,0,0,0,0,0,0],
              [0,0,1,0,0,0,0,0],
              [0,1,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0]
            ],
            value: 300,
            comment: "X-スクエアを安全に避けた配置"
          },
          {
            name: "エッジ制御パターン",
            masks: [
              [0,0,0,0,0,1,1,1],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0]
            ],
            templates: [
              [0,0,0,0,0,1,1,1],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0]
            ],
            value: 200,
            comment: "安定したエッジ支配パターン"
          },
          // 他にも多数のパターンを定義可能
        ];
      }
      
      // ボードにパターンがマッチするか確認
      matchPatterns(board, player) {
        const opponent = player === BLACK ? WHITE : BLACK;
        let totalValue = 0;
        let matchedPatterns = [];
        
        // 各パターンについてチェック
        for (const pattern of this.patterns) {
          // 8方向の対称性をチェック
          for (let rot = 0; rot < 4; rot++) { // 4つの回転
            for (let flip = 0; flip < 2; flip++) { // 2つの反転
              const match = this.checkPatternMatch(
                board, player, opponent, pattern, rot, flip === 1
              );
              
              if (match) {
                totalValue += pattern.value;
                matchedPatterns.push(pattern.name);
                break; // このパターンはマッチしたのでループを抜ける
              }
            }
          }
        }
        
        return {
          value: totalValue,
          patterns: matchedPatterns
        };
      }
      
      // 特定の向きでパターンがマッチするかチェック
      checkPatternMatch(board, player, opponent, pattern, rotation, flipped) {
        const masks = this.transformPattern(pattern.masks, rotation, flipped);
        const templates = this.transformPattern(pattern.templates, rotation, flipped);
        
        for (let y = 0; y < BOARD_SIZE; y++) {
          for (let x = 0; x < BOARD_SIZE; x++) {
            if (masks[y][x] === 1) {
              // テンプレートの期待値によってチェック
              if (templates[y][x] === 1 && board[y][x] !== player) return false;
              if (templates[y][x] === 2 && board[y][x] !== opponent) return false;
              if (templates[y][x] === 0 && board[y][x] !== EMPTY) return false;
            }
          }
        }
        
        return true;
      }
      
      // パターン配列を回転・反転
      transformPattern(pattern, rotation, flipped) {
        let result = JSON.parse(JSON.stringify(pattern)); // ディープコピー
        
        // 反転
        if (flipped) {
          result = result.map(row => [...row].reverse());
        }
        
        // 回転
        for (let r = 0; r < rotation; r++) {
          const newResult = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
          for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
              newResult[x][BOARD_SIZE - 1 - y] = result[y][x];
            }
          }
          result = newResult;
        }
        
        return result;
      }
    }
    
    // ゲーム状態
    const gameState = {
      board: null,
      currentPlayer: BLACK,
      gameOver: false,
      lastMove: null,
      ttable: new TranspositionTable(4194304), // 2^22 サイズ（4M）に拡大
      patternRecognizer: new PatternRecognizer(),
      aiThinking: false,
      aiLevel: 3,
      aiTimeLimit: 15000, // デフォルト15秒
      moveCount: 0,
      openingUsed: null,  // 現在使用中の定石
      openingMoveIndex: 0, // 定石内の現在の手数
      moveSequence: [],   // これまでの手順を記録
      flippedPositions: [], // 裏返された石の位置
      currentThinkingDepth: 0, // 現在の思考深度
      bestMoves: [], // AIが評価した上位の手
      winProbability: 50, // 勝率予想
      moveHistory: [], // 棋譜履歴
      worker: null, // WebWorker
      usingWebWorker: false, // WebWorker使用フラグ
      debugMode: false // デバッグモード
    };
    
    // UI要素
    const boardElement = document.getElementById('board');
    const blackCountElement = document.getElementById('blackCount');
    const whiteCountElement = document.getElementById('whiteCount');
    const statusDisplayElement = document.getElementById('statusDisplay');
    const newGameButton = document.getElementById('newGameBtn');
    const playerColorSelect = document.getElementById('playerColor');
    const aiLevelSelect = document.getElementById('aiLevel');
    const thinkingTimeSelect = document.getElementById('thinkingTime');
    const thinkingElement = document.getElementById('thinking');
    const thinkDepthElement = document.getElementById('thinkDepth');
    const thinkingProgressElement = document.getElementById('thinkingProgress');
    const depthProgressElement = document.getElementById('depthProgress');
    const openingInfoElement = document.getElementById('openingInfo');
    const gamePhaseElement = document.getElementById('gamePhase');
    const winProbabilityElement = document.getElementById('winProbability');
    const winProbabilityBarElement = document.getElementById('winProbabilityBar');
    const moveHistoryElement = document.getElementById('moveHistory');
    const strategyAnalysisElement = document.getElementById('strategyAnalysis');
    const bestMoveContainerElement = document.getElementById('bestMoveContainer');
    const bestMove1Element = document.getElementById('bestMove1');
    const bestMove2Element = document.getElementById('bestMove2');
    const bestMove3Element = document.getElementById('bestMove3');
    const debugInfoElement = document.getElementById('debugInfo');
    const debugContentElement = document.getElementById('debugContent');
    const toggleDebugButton = document.getElementById('toggleDebug');
    const tableSizeElement = document.getElementById('tableSize');
    const openingCountElement = document.getElementById('openingCount');
    const maxDepthElement = document.getElementById('maxDepth');
    
    // WebWorkerのサポート確認と初期化
    function initializeWebWorker() {
      if (window.Worker) {
        try {
          // インラインWebWorkerを作成
          const workerCode = `
            self.onmessage = function(e) {
              const { board, player, depth, alpha, beta, timeLimit } = e.data;
              
              // 制限時間チェック用
              const startTime = Date.now();
              
              // 思考深度の進捗通知用
              let currentDepth = 0;
              
              // ミニマックス（アルファベータ法）の実装
              function minimax(board, depth, alpha, beta, player, maximizingPlayer, topLevel = false) {
                // 時間制限チェック
                if (Date.now() - startTime > timeLimit) {
                  return { timeOut: true };
                }
                
                // 現在の深度を親に通知
                if (topLevel && currentDepth !== depth) {
                  currentDepth = depth;
                  self.postMessage({ type: 'depthProgress', depth: currentDepth });
                }
                
                // 終了条件
                if (depth === 0) {
                  return { value: evaluateBoard(board, maximizingPlayer) };
                }
                
                const opponent = player === 1 ? 2 : 1; // BLACK=1, WHITE=2
                const validMoves = getValidMoves(board, player);
                
                // 有効な手がない場合
                if (validMoves.length === 0) {
                  // 相手も手がない場合は終局
                  if (getValidMoves(board, opponent).length === 0) {
                    // 石差で評価
                    const counts = countDiscs(board);
                    if (maximizingPlayer === 1) { // BLACK
                      return { value: counts.black > counts.white ? 10000 : (counts.black < counts.white ? -10000 : 0) };
                    } else {
                      return { value: counts.white > counts.black ? 10000 : (counts.white < counts.black ? -10000 : 0) };
                    }
                  }
                  
                  // パスの場合は相手番
                  return minimax(board, depth - 1, alpha, beta, opponent, maximizingPlayer);
                }
                
                // 角を優先するソート
                validMoves.sort((a, b) => {
                  const aIsCorner = (a.x === 0 || a.x === 7) && (a.y === 0 || a.y === 7);
                  const bIsCorner = (b.x === 0 || b.x === 7) && (b.y === 0 || b.y === 7);
                  
                  if (aIsCorner && !bIsCorner) return -1;
                  if (!aIsCorner && bIsCorner) return 1;
                  
                  return 0;
                });
                
                let bestMove = null;
                let bestValue = player === maximizingPlayer ? -Infinity : Infinity;
                let allMoves = [];
                
                for (const move of validMoves) {
                  // 次の盤面を生成
                  const nextBoard = cloneBoard(board);
                  nextBoard[move.y][move.x] = player;
                  
                  // 挟まれた石を裏返す
                  const flipped = getFlippedPositions(board, move.x, move.y, player);
                  for (const [fy, fx] of flipped) {
                    nextBoard[fy][fx] = player;
                  }
                  
                  // 再帰的に評価
                  const result = minimax(nextBoard, depth - 1, alpha, beta, opponent, maximizingPlayer);
                  
                  // タイムアウト判定
                  if (result.timeOut) return { timeOut: true };
                  
                  // トップレベルでは全ての手の評価値を記録
                  if (topLevel) {
                    allMoves.push({
                      x: move.x,
                      y: move.y,
                      value: result.value
                    });
                  }
                  
                  if (player === maximizingPlayer) {
                    if (result.value > bestValue) {
                      bestValue = result.value;
                      bestMove = move;
                    }
                    alpha = Math.max(alpha, bestValue);
                  } else {
                    if (result.value < bestValue) {
                      bestValue = result.value;
                      bestMove = move;
                    }
                    beta = Math.min(beta, bestValue);
                  }
                  
                  // アルファベータカット
                  if (beta <= alpha) break;
                }
                
                if (topLevel) {
                  return { value: bestValue, move: bestMove, allMoves: allMoves };
                }
                return { value: bestValue, move: bestMove };
              }
              
              // 盤面評価関数
              function evaluateBoard(board, maximizingPlayer) {
                const player = maximizingPlayer;
                const opponent = player === 1 ? 2 : 1;
                
                // 各評価項目のスコア初期化
                let mobilityScore = 0;
                let positionalScore = 0;
                let cornerScore = 0;
                let stabilityScore = 0;
                let parityScore = 0;
                
                // 1. 着手可能場所数（モビリティ）評価
                const playerMoves = getValidMoves(board, player).length;
                const opponentMoves = getValidMoves(board, opponent).length;
                mobilityScore = playerMoves - opponentMoves;
                
                // 2. マス位置評価
                const CORNER_VALUE = 3000;
                const X_SQUARE_VALUE = -1500;
                const POSITION_WEIGHTS = [
                  [CORNER_VALUE, -150, 30, 10, 10, 30, -150, CORNER_VALUE],
                  [-150, X_SQUARE_VALUE, -15, -3, -3, -15, X_SQUARE_VALUE, -150],
                  [30, -15, 40, 2, 2, 40, -15, 30],
                  [10, -3, 2, 5, 5, 2, -3, 10],
                  [10, -3, 2, 5, 5, 2, -3, 10],
                  [30, -15, 40, 2, 2, 40, -15, 30],
                  [-150, X_SQUARE_VALUE, -15, -3, -3, -15, X_SQUARE_VALUE, -150],
                  [CORNER_VALUE, -150, 30, 10, 10, 30, -150, CORNER_VALUE]
                ];
                
                for (let y = 0; y < 8; y++) {
                  for (let x = 0; x < 8; x++) {
                    if (board[y][x] === player) {
                      positionalScore += POSITION_WEIGHTS[y][x];
                    } else if (board[y][x] === opponent) {
                      positionalScore -= POSITION_WEIGHTS[y][x];
                    }
                  }
                }
                
                // 3. 角の評価（特に重要）
                const CORNER_POSITIONS = [[0, 0], [0, 7], [7, 0], [7, 7]];
                for (const [y, x] of CORNER_POSITIONS) {
                  if (board[y][x] === player) {
                    cornerScore += CORNER_VALUE;
                  } else if (board[y][x] === opponent) {
                    cornerScore -= CORNER_VALUE;
                  }
                }
                
                // 4. 安定石の評価
                for (let y = 0; y < 8; y++) {
                  for (let x = 0; x < 8; x++) {
                    if (board[y][x] !== 0) {
                      // 簡易的な安定石判定
                      let isStable = false;
                      // 角は常に安定
                      if ((x === 0 || x === 7) && (y === 0 || y === 7)) {
                        isStable = true;
                      }
                      // 辺が埋まっている場合も比較的安定
                      else if (x === 0 || x === 7 || y === 0 || y === 7) {
                        let edgeFilled = true;
                        if (x === 0) {
                          for (let i = 0; i < 8; i++) {
                            if (board[i][0] === 0) {
                              edgeFilled = false;
                              break;
                            }
                          }
                        } else if (x === 7) {
                          for (let i = 0; i < 8; i++) {
                            if (board[i][7] === 0) {
                              edgeFilled = false;
                              break;
                            }
                          }
                        } else if (y === 0) {
                          for (let i = 0; i < 8; i++) {
                            if (board[0][i] === 0) {
                              edgeFilled = false;
                              break;
                            }
                          }
                        } else if (y === 7) {
                          for (let i = 0; i < 8; i++) {
                            if (board[7][i] === 0) {
                              edgeFilled = false;
                              break;
                            }
                          }
                        }
                        
                        if (edgeFilled) {
                          isStable = true;
                        }
                      }
                      
                      if (isStable) {
                        if (board[y][x] === player) {
                          stabilityScore += 50;
                        } else {
                          stabilityScore -= 50;
                        }
                      }
                    }
                  }
                }
                
                // 5. パリティ評価（終盤に重要）
                const { black, white } = countDiscs(board);
                const emptyCount = 64 - black - white;
                if (emptyCount <= 16) { // 終盤ではパリティが重要
                  if (emptyCount % 2 === 0) { // 偶数なら後手有利
                    parityScore = player === 2 ? 50 : -50;
                  } else { // 奇数なら先手有利
                    parityScore = player === 1 ? 50 : -50;
                  }
                }
                
                // 石差の評価（終盤に重要）
                const discDiff = player === 1 ? (black - white) : (white - black);
                
                // 空きマス数に基づくゲームフェーズ
                const emptyCount = 64 - black - white;
                
                // ゲームフェーズに応じた重み付け
                let finalScore = 0;
                
                if (emptyCount > 40) { // 序盤
                  finalScore = 
                    positionalScore * 1.0 +
                    mobilityScore * 5.0 +
                    cornerScore * 35.0 +
                    stabilityScore * 1.0;
                } else if (emptyCount > 20) { // 中盤
                  finalScore = 
                    positionalScore * 1.0 +
                    mobilityScore * 3.0 +
                    cornerScore * 25.0 +
                    stabilityScore * 2.0 +
                    discDiff * 1.0;
                } else if (emptyCount > 10) { // 終盤序盤
                  finalScore = 
                    positionalScore * 0.5 +
                    mobilityScore * 2.0 +
                    cornerScore * 15.0 +
                    stabilityScore * 5.0 +
                    discDiff * 5.0 +
                    parityScore * 2.0;
                } else { // 終盤
                  finalScore = 
                    cornerScore * 10.0 +
                    stabilityScore * 10.0 +
                    discDiff * 10.0 +
                    parityScore * 5.0;
                }
                
                return finalScore;
              }
              
              // 有効な手を取得
              function getValidMoves(board, player) {
                const moves = [];
                const DIRECTIONS = [
                  [-1, -1], [-1, 0], [-1, 1],
                  [0, -1],           [0, 1],
                  [1, -1],  [1, 0],  [1, 1]
                ];
                
                for (let y = 0; y < 8; y++) {
                  for (let x = 0; x < 8; x++) {
                    if (isValidMove(board, x, y, player)) {
                      moves.push({x, y});
                    }
                  }
                }
                
                return moves;
                
                // 有効な手かどうか判定
                function isValidMove(board, x, y, player) {
                  if (board[y][x] !== 0) return false;
                  
                  return getFlippedPositions(board, x, y, player).length > 0;
                }
                
                // 裏返される石の位置を取得
                function getFlippedPositions(board, x, y, player) {
                  const opponent = player === 1 ? 2 : 1;
                  const flipped = [];
                  
                  for (const [dy, dx] of DIRECTIONS) {
                    let nx = x + dx;
                    let ny = y + dy;
                    const tempFlipped = [];
                    
                    while (
                      nx >= 0 && nx < 8 &&
                      ny >= 0 && ny < 8 &&
                      board[ny][nx] === opponent
                    ) {
                      tempFlipped.push([ny, nx]);
                      nx += dx;
                      ny += dy;
                    }
                    
                    if (
                      tempFlipped.length > 0 &&
                      nx >= 0 && nx < 8 &&
                      ny >= 0 && ny < 8 &&
                      board[ny][nx] === player
                    ) {
                      flipped.push(...tempFlipped);
                    }
                  }
                  
                  return flipped;
                }
              }
              
              // 裏返される石の位置を取得
              function getFlippedPositions(board, x, y, player) {
                const opponent = player === 1 ? 2 : 1;
                const flipped = [];
                const DIRECTIONS = [
                  [-1, -1], [-1, 0], [-1, 1],
                  [0, -1],           [0, 1],
                  [1, -1],  [1, 0],  [1, 1]
                ];
                
                for (const [dy, dx] of DIRECTIONS) {
                  let nx = x + dx;
                  let ny = y + dy;
                  const tempFlipped = [];
                  
                  while (
                    nx >= 0 && nx < 8 &&
                    ny >= 0 && ny < 8 &&
                    board[ny][nx] === opponent
                  ) {
                    tempFlipped.push([ny, nx]);
                    nx += dx;
                    ny += dy;
                  }
                  
                  if (
                    tempFlipped.length > 0 &&
                    nx >= 0 && nx < 8 &&
                    ny >= 0 && ny < 8 &&
                    board[ny][nx] === player
                  ) {
                    flipped.push(...tempFlipped);
                  }
                }
                
                return flipped;
              }
              
              // 盤面を複製
              function cloneBoard(board) {
                return board.map(row => [...row]);
              }
              
              // 石の数をカウント
              function countDiscs(board) {
                let black = 0, white = 0;
                
                for (let y = 0; y < 8; y++) {
                  for (let x = 0; x < 8; x++) {
                    if (board[y][x] === 1) black++;
                    else if (board[y][x] === 2) white++;
                  }
                }
                
                return { black, white };
              }
              
              // 探索の実行
              const result = minimax(board, depth, alpha, beta, player, player, true);
              
              // 結果を返信
              self.postMessage({
                type: 'result',
                timeOut: result.timeOut || false,
                move: result.move,
                value: result.value,
                allMoves: result.allMoves || [],
                depth: currentDepth
              });
            };
          `;
          
          // Blobを作成しURLに変換
          const blob = new Blob([workerCode], { type: 'application/javascript' });
          const workerUrl = URL.createObjectURL(blob);
          
          // Workerを作成
          gameState.worker = new Worker(workerUrl);
          
          // メッセージハンドラを設定
          gameState.worker.onmessage = function(e) {
            const data = e.data;
            
            if (data.type === 'depthProgress') {
              // 深度進捗の更新
              gameState.currentThinkingDepth = data.depth;
              thinkDepthElement.textContent = `深度: ${data.depth}`;
              depthProgressElement.textContent = `${data.depth}手先読み中`;
            }
            else if (data.type === 'result') {
              // 思考結果の処理
              if (data.timeOut) {
                // タイムアウトした場合は、これまでの最善手を使用
                updateDebugInfo("思考タイムアウト - 最善手使用");
              }
              
              if (data.move) {
                const { x, y } = data.move;
                
                // 上位3手を記録
                if (data.allMoves && data.allMoves.length > 0) {
                  // 評価値でソート
                  const sortedMoves = data.allMoves.sort((a, b) => b.value - a.value).slice(0, 3);
                  gameState.bestMoves = sortedMoves;
                  displayBestMoves(sortedMoves);
                }
                
                // 勝率予測の更新
                updateWinProbability(data.value);
                
                // 手を実行
                makeMove(x, y);
              } else {
                // 手がない場合（通常はこのケースはないはず）
                updateDebugInfo("AIが手を見つけられませんでした");
              }
              
              // AI思考終了処理
              thinkingElement.classList.add('hidden');
              thinkDepthElement.classList.add('hidden');
              thinkingProgressElement.classList.add('hidden');
              gameState.aiThinking = false;
            }
          };
          
          gameState.usingWebWorker = true;
          updateDebugInfo("WebWorker initialized successfully");
        } catch (e) {
          console.error("WebWorker initialization failed:", e);
          gameState.usingWebWorker = false;
          updateDebugInfo("WebWorker初期化失敗: " + e.message);
        }
      } else {
        gameState.usingWebWorker = false;
        updateDebugInfo("WebWorker not supported in this browser");
      }
    }
    
    // 盤面の初期化
    function initializeBoard() {
      const board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(EMPTY));
      board[3][3] = WHITE;
      board[3][4] = BLACK;
      board[4][3] = BLACK;
      board[4][4] = WHITE;
      return board;
    }
    
    // 新しいゲームを開始
    function newGame() {
      gameState.board = initializeBoard();
      gameState.currentPlayer = BLACK;
      gameState.gameOver = false;
      gameState.lastMove = null;
      gameState.ttable.clear();
      gameState.aiThinking = false;
      gameState.moveCount = 0;
      gameState.openingUsed = null;
      gameState.openingMoveIndex = 0;
      gameState.moveSequence = [];
      gameState.flippedPositions = [];
      gameState.currentThinkingDepth = 0;
      gameState.bestMoves = [];
      gameState.winProbability = 50;
      gameState.moveHistory = [];
      
      // 思考時間の設定
      gameState.aiTimeLimit = parseInt(thinkingTimeSelect.value);
      
      // AIレベルの設定
      gameState.aiLevel = parseInt(aiLevelSelect.value);
      
      renderBoard();
      updateStatus();
      updateOpeningInfo();
      updateDebugInfo("新しいゲームを開始しました");
      updateStrategyAnalysis("ゲームを開始します。初手は通常E6(d3)またはF5(f4)が選ばれます。角の確保を意識しましょう。");
      moveHistoryElement.innerHTML = "";
      updateWinProbability(0);
      bestMoveContainerElement.classList.add('hidden');
      
      // プレイヤーが白なら、AIが先行
      if (playerColorSelect.value === 'white') {
        setTimeout(() => makeAIMove(), 500);
      }
    }
    
    // UIの盤面を描画
    function renderBoard() {
      boardElement.innerHTML = '';
      
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          const cell = document.createElement('div');
          cell.className = 'board-cell';
          cell.dataset.x = x;
          cell.dataset.y = y;
          
          // 角のセルにコーナースタイルを適用
          if ((x === 0 || x === 7) && (y === 0 || y === 7)) {
            cell.classList.add('corner');
          }
          
          // 定石のヒント表示 (現在の定石に従った次の手)
          if (gameState.openingUsed && 
              gameState.openingMoveIndex < gameState.openingUsed.seq.length &&
              gameState.openingUsed.seq[gameState.openingMoveIndex][0] === y &&
              gameState.openingUsed.seq[gameState.openingMoveIndex][1] === x) {
            cell.classList.add('opening-hint');
          }
          
          // 石がある場合は表示
          if (gameState.board[y][x] !== EMPTY) {
            const disc = document.createElement('div');
            disc.className = `disc ${gameState.board[y][x] === BLACK ? 'black' : 'white'}`;
            
            // アニメーション付与
            if (gameState.flippedPositions.some(pos => pos[0] === y && pos[1] === x)) {
              disc.classList.add('flip');
            }
            
            cell.appendChild(disc);
            cell.classList.add('occupied');
          }
          
          // 最後の手を強調表示
          if (gameState.lastMove && gameState.lastMove.x === x && gameState.lastMove.y === y) {
            cell.classList.add('last-move');
          }
          
          // プレイヤーが現在のプレイヤーであれば、有効な手を強調表示
          const isPlayerTurn = (gameState.currentPlayer === BLACK && playerColorSelect.value === 'black') ||
                              (gameState.currentPlayer === WHITE && playerColorSelect.value === 'white');
          
          if (isPlayerTurn && isValidMove(gameState.board, x, y, gameState.currentPlayer)) {
            cell.classList.add('valid-move');
          }
          
          // クリックイベント
          cell.addEventListener('click', () => handleCellClick(x, y));
          
          boardElement.appendChild(cell);
        }
      }
    }
    
    // 最善手の表示
    function displayBestMoves(moves) {
      if (!moves || moves.length === 0) {
        bestMoveContainerElement.classList.add('hidden');
        return;
      }
      
      bestMoveContainerElement.classList.remove('hidden');
      
      // 座標をアルファベット表記に変換する関数
      const toAlphabet = (x, y) => `${String.fromCharCode(97 + x)}${y + 1}`;
      
      // 各手の表示をセット
      if (moves.length > 0) {
        const move1 = moves[0];
        bestMove1Element.innerHTML = `
          <div class="font-bold">最善手: ${toAlphabet(move1.x, move1.y)}</div>
          <div>評価値: ${move1.value.toFixed(1)}</div>
        `;
      }
      
      if (moves.length > 1) {
        const move2 = moves[1];
        bestMove2Element.innerHTML = `
          <div class="font-bold">第2候補: ${toAlphabet(move2.x, move2.y)}</div>
          <div>評価値: ${move2.value.toFixed(1)}</div>
        `;
      }
      
      if (moves.length > 2) {
        const move3 = moves[2];
        bestMove3Element.innerHTML = `
          <div class="font-bold">第3候補: ${toAlphabet(move3.x, move3.y)}</div>
          <div>評価値: ${move3.value.toFixed(1)}</div>
        `;
      }
    }
    
    // 勝率予測の更新
    function updateWinProbability(value) {
      // 評価値から勝率への変換
      // 評価値の範囲は基本的に -3000 ～ +3000 程度を想定
      
      let probability = 50;
      
      if (value === 0) {
        probability = 50;
      } else if (value > 5000) {
        probability = 99;
      } else if (value < -5000) {
        probability = 1;
      } else {
        // シグモイド関数で変換
        probability = Math.round(100 / (1 + Math.exp(-value / 500)));
      }
      
      // 現在の手番が白の場合は反転
      if (gameState.currentPlayer === WHITE) {
        probability = 100 - probability;
      }
      
      gameState.winProbability = probability;
      
      // UI更新
      winProbabilityElement.textContent = `${probability}%`;
      winProbabilityBarElement.style.width = `${probability}%`;
    }
    
    // 戦略分析の更新
    function updateStrategyAnalysis(message) {
      strategyAnalysisElement.textContent = message;
    }
    
    // セルクリック時の処理
    function handleCellClick(x, y) {
      if (gameState.aiThinking || gameState.gameOver) return;
      
      const isPlayerTurn = (gameState.currentPlayer === BLACK && playerColorSelect.value === 'black') ||
                          (gameState.currentPlayer === WHITE && playerColorSelect.value === 'white');
      
      if (!isPlayerTurn) return;
      
      if (isValidMove(gameState.board, x, y, gameState.currentPlayer)) {
        makeMove(x, y);
        
        // 少し遅延させてから AI の手を打つ
        setTimeout(() => {
          // AI の手番かどうかチェック
          if (!gameState.gameOver && 
              ((gameState.currentPlayer === BLACK && playerColorSelect.value === 'white') ||
               (gameState.currentPlayer === WHITE && playerColorSelect.value === 'black'))) {
            makeAIMove();
          }
        }, 500);
      }
    }
    
    // 指定した位置に石を置く
    function makeMove(x, y) {
      if (!isValidMove(gameState.board, x, y, gameState.currentPlayer)) return false;
      
      const flippedPositions = getFlippedPositions(gameState.board, x, y, gameState.currentPlayer);
      gameState.flippedPositions = flippedPositions;
      
      // 石を置く
      gameState.board[y][x] = gameState.currentPlayer;
      
      // 挟まれた石を裏返す
      for (const [fy, fx] of flippedPositions) {
        gameState.board[fy][fx] = gameState.currentPlayer;
      }
      
      // 最後の手を記録
      gameState.lastMove = {x, y};
      gameState.moveCount++;
      
      // 手順履歴に追加
      gameState.moveSequence.push([y, x, gameState.currentPlayer]);
      
      // 棋譜に追加
      addMoveToHistory(x, y, gameState.currentPlayer, flippedPositions.length);
      
      // 定石の進行を更新
      updateOpeningProgress(x, y);
      
      // プレイヤーの切り替え
      switchPlayer();
      
      // UI更新
      renderBoard();
      updateStatus();
      
      return true;
    }
    
    // 棋譜に手を追加
    function addMoveToHistory(x, y, player, flippedCount) {
      const moveNotation = `${String.fromCharCode(97 + x)}${y + 1}`;
      const playerChar = player === BLACK ? "●" : "○";
      
      const moveInfo = {
        x, y, player, flippedCount, notation: moveNotation
      };
      
      gameState.moveHistory.push(moveInfo);
      
      // 表示を更新
      const moveText = `${gameState.moveHistory.length}. ${playerChar}${moveNotation}(${flippedCount})`;
      
      const moveElem = document.createElement('span');
      moveElem.textContent = moveText;
      moveElem.className = 'mr-2';
      
      if (gameState.moveHistory.length % 16 === 0) {
        moveElem.className += ' block';
      }
      
      moveHistoryElement.appendChild(moveElem);
      
      // スクロールを一番下に
      moveHistoryElement.scrollTop = moveHistoryElement.scrollHeight;
    }
    
    // 定石の進行状況を更新
    function updateOpeningProgress(x, y) {
      // 現在定石使用中の場合
      if (gameState.openingUsed) {
        // 次の定石手と一致するか確認
        if (gameState.openingMoveIndex < gameState.openingUsed.seq.length &&
            gameState.openingUsed.seq[gameState.openingMoveIndex][1] === x &&
            gameState.openingUsed.seq[gameState.openingMoveIndex][0] === y) {
          
          // 定石に従った手なので、インデックスを進める
          gameState.openingMoveIndex++;
          
          // 定石が終了したか確認
          if (gameState.openingMoveIndex >= gameState.openingUsed.seq.length) {
            // 定石完了のメッセージ
            updateOpeningInfo("定石完了 - 次は中盤戦略へ");
            updateStrategyAnalysis(gameState.openingUsed.comment || "定石が完了しました。角や安定石の確保を意識した中盤戦略に移行しましょう。");
            gameState.openingUsed = null;
          } else {
            // 定石進行中
            updateOpeningInfo();
          }
        } else {
          // 定石から外れた手
          findMatchingOpening();
        }
      } else {
        // 定石使用中でない場合、マッチする定石がないか探す
        findMatchingOpening();
      }
    }
    
    // マッチする定石を探す
    function findMatchingOpening() {
      // 最近の数手から定石をマッチングするための手数
      const matchLimit = 8;
      const recentMoves = gameState.moveSequence.slice(-matchLimit);
      
      if (recentMoves.length < 2) return; // 最低2手は必要
      
      // 定石データベースから最も一致度の高い定石を探す
      let bestMatch = null;
      let bestMatchScore = 0;
      let bestMatchIndex = 0;
      
      for (const opening of OPENINGS) {
        // 定石の各手順位置から開始してマッチングを試みる
        for (let startIdx = 0; startIdx < opening.seq.length; startIdx++) {
          let matchScore = 0;
          let matches = 0;
          
          // 最近の手とのマッチングをチェック
          for (let i = 0; i < Math.min(recentMoves.length, opening.seq.length - startIdx); i++) {
            const [moveY, moveX, _] = recentMoves[recentMoves.length - 1 - i];
            const [seqY, seqX] = opening.seq[startIdx + i];
            
            if (moveY === seqY && moveX === seqX) {
              matches++;
            }
          }
          
          matchScore = matches / Math.min(recentMoves.length, opening.seq.length - startIdx);
          
          // より良いマッチが見つかれば更新
          if (matchScore > bestMatchScore) {
            bestMatch = opening;
            bestMatchScore = matchScore;
            bestMatchIndex = startIdx + matches;
          }
        }
      }
      
      // 十分に高いマッチング率があれば定石として採用
      if (bestMatch && bestMatchScore >= 0.7) {
        gameState.openingUsed = bestMatch;
        gameState.openingMoveIndex = bestMatchIndex;
        updateOpeningInfo("定石一致: " + bestMatch.name);
        updateStrategyAnalysis(bestMatch.comment || "この定石は角の確保を優先する強力な戦略です。");
        
        // デバッグ情報の更新
        updateDebugInfo(
          `定石一致: ${bestMatch.name}, 一致度: ${(bestMatchScore * 100).toFixed(1)}%, ` +
          `手順: ${bestMatchIndex}/${bestMatch.seq.length}`
        );
      } else {
        // 定石が見つからなかった場合
        gameState.openingUsed = null;
        updateOpeningInfo("定石未検出");
        
        // 中盤の戦略アドバイスを生成
        generateMidgameStrategy();
      }
    }
    
    // 中盤の戦略アドバイスを生成
    function generateMidgameStrategy() {
      const counts = countDiscs(gameState.board);
      const emptyCount = 64 - counts.black - counts.white;
      
      let strategyMessage = "";
      
      // 角の確保状況
      const corners = [
        [0, 0], [0, 7], [7, 0], [7, 7]
      ];
      
      let blackCorners = 0, whiteCorners = 0;
      for (const [y, x] of corners) {
        if (gameState.board[y][x] === BLACK) blackCorners++;
        else if (gameState.board[y][x] === WHITE) whiteCorners++;
      }
      
      // 序盤のアドバイス
      if (emptyCount > 40) {
        strategyMessage = "序盤戦です。モビリティ（着手可能箇所）を意識し、X-スクエアへの着手を避けましょう。";
      }
      // 中盤のアドバイス
      else if (emptyCount > 20) {
        if (gameState.currentPlayer === BLACK) {
          if (blackCorners > whiteCorners) {
            strategyMessage = "角を既に確保しています。角から辺に向かって安定石を増やしていきましょう。";
          } else if (blackCorners < whiteCorners) {
            strategyMessage = "相手が角を確保しています。残りの角を狙うか、モビリティを確保する戦略が有効です。";
          } else {
            strategyMessage = "中盤戦です。角の争いが重要になります。X-スクエアを避けつつ角への布石を打ちましょう。";
          }
        } else {
          if (whiteCorners > blackCorners) {
            strategyMessage = "角を既に確保しています。角から辺に向かって安定石を増やしていきましょう。";
          } else if (whiteCorners < blackCorners) {
            strategyMessage = "相手が角を確保しています。残りの角を狙うか、モビリティを確保する戦略が有効です。";
          } else {
            strategyMessage = "中盤戦です。角の争いが重要になります。X-スクエアを避けつつ角への布石を打ちましょう。";
          }
        }
      }
      // 終盤のアドバイス
      else {
        if (emptyCount % 2 === 0) {
          strategyMessage = "終盤戦です。パリティが偶数のため、最後の手を打つプレイヤーが有利です。";
        } else {
          strategyMessage = "終盤戦です。パリティが奇数のため、最後の手を打たないプレイヤーが有利です。";
        }
        
        if (emptyCount <= 10) {
          strategyMessage += " 石数の最大化を意識した手を選びましょう。";
        }
      }
      
      updateStrategyAnalysis(strategyMessage);
    }
    
    // 定石情報の更新
    function updateOpeningInfo(customMessage = null) {
      if (customMessage) {
        openingInfoElement.textContent = customMessage;
        return;
      }
      
      if (gameState.openingUsed) {
        openingInfoElement.textContent = 
          `定石: ${gameState.openingUsed.name} (評価値: ${gameState.openingUsed.eval}) - ` +
          `手順: ${gameState.openingMoveIndex}/${gameState.openingUsed.seq.length}`;
      } else {
        openingInfoElement.textContent = "定石未使用";
      }
    }
    
    // デバッグ情報の更新
    function updateDebugInfo(message) {
      // デバッグメッセージを追加（最大5件まで保持）
      const lines = debugContentElement.textContent.split('\n').filter(line => line.trim() !== '');
      lines.unshift(new Date().toLocaleTimeString() + ': ' + message);
      debugContentElement.textContent = lines.slice(0, 5).join('\n');
    }
    
    // 有効な手かどうか判定
    function isValidMove(board, x, y, player) {
      if (board[y][x] !== EMPTY) return false;
      
      return getFlippedPositions(board, x, y, player).length > 0;
    }
    
    // 裏返される石の位置を取得
    function getFlippedPositions(board, x, y, player) {
      const opponent = player === BLACK ? WHITE : BLACK;
      const flipped = [];
      
      for (const [dy, dx] of DIRECTIONS) {
        let nx = x + dx;
        let ny = y + dy;
        const tempFlipped = [];
        
        while (
          nx >= 0 && nx < BOARD_SIZE &&
          ny >= 0 && ny < BOARD_SIZE &&
          board[ny][nx] === opponent
        ) {
          tempFlipped.push([ny, nx]);
          nx += dx;
          ny += dy;
        }
        
        if (
          tempFlipped.length > 0 &&
          nx >= 0 && nx < BOARD_SIZE &&
          ny >= 0 && ny < BOARD_SIZE &&
          board[ny][nx] === player
        ) {
          flipped.push(...tempFlipped);
        }
      }
      
      return flipped;
    }
    
    // プレイヤーの切り替え
    function switchPlayer() {
      gameState.currentPlayer = gameState.currentPlayer === BLACK ? WHITE : BLACK;
      
      // パスチェック
      const hasValidMoves = hasAnyValidMoves(gameState.board, gameState.currentPlayer);
      
      if (!hasValidMoves) {
        // 相手もパスならゲーム終了
        const opponentHasValidMoves = hasAnyValidMoves(
          gameState.board, 
          gameState.currentPlayer === BLACK ? WHITE : BLACK
        );
        
        if (!opponentHasValidMoves) {
          gameState.gameOver = true;
          const counts = countDiscs(gameState.board);
          
          let winner;
          if (counts.black > counts.white) {
            winner = '黒の勝利！';
            updateWinProbability(10000); // 黒の完全勝利
          } else if (counts.white > counts.black) {
            winner = '白の勝利！';
            updateWinProbability(-10000); // 白の完全勝利
          } else {
            winner = '引き分け！';
            updateWinProbability(0); // 引き分け
          }
          
          updateStrategyAnalysis(`ゲーム終了 - ${winner} 黒${counts.black}石、白${counts.white}石でした。`);
        } else {
          // パスして相手のターンに
          gameState.currentPlayer = gameState.currentPlayer === BLACK ? WHITE : BLACK;
          statusDisplayElement.textContent = 'パス - ' + 
            (gameState.currentPlayer === BLACK ? '黒' : '白') + 'の手番です';
          updateStrategyAnalysis("有効な手がないためパスしました。相手の手番に移ります。");
        }
      }
    }
    
    // 有効な手があるか判定
    function hasAnyValidMoves(board, player) {
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (isValidMove(board, x, y, player)) {
            return true;
          }
        }
      }
      return false;
    }
    
    // すべての有効な手を取得
    function getValidMoves(board, player) {
      const moves = [];
      
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (isValidMove(board, x, y, player)) {
            moves.push({x, y});
          }
        }
      }
      
      return moves;
    }
    
    // 盤面を複製
    function cloneBoard(board) {
      return board.map(row => [...row]);
    }
    
    // 石の数をカウント
    function countDiscs(board) {
      let black = 0, white = 0;
      
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x] === BLACK) black++;
          else if (board[y][x] === WHITE) white++;
        }
      }
      
      return { black, white };
    }
    
    // ゲーム状態の更新
    function updateStatus() {
      const counts = countDiscs(gameState.board);
      blackCountElement.textContent = counts.black;
      whiteCountElement.textContent = counts.white;
      
      // ゲームフェーズの判定
      const emptyCount = 64 - counts.black - counts.white;
      let phase;
      if (emptyCount > 45) phase = "序盤";
      else if (emptyCount > 30) phase = "序中盤";
      else if (emptyCount > 15) phase = "中盤";
      else if (emptyCount > 7) phase = "中終盤";
      else phase = "終盤";
      
      gamePhaseElement.textContent = phase;
      
      if (gameState.gameOver) {
        let winner;
        if (counts.black > counts.white) winner = '黒の勝利！';
        else if (counts.white > counts.black) winner = '白の勝利！';
        else winner = '引き分け！';
        
        statusDisplayElement.textContent = 'ゲーム終了 - ' + winner;
        statusDisplayElement.className = 'px-3 py-1 rounded bg-gray-800 text-white font-bold';
      } else {
        statusDisplayElement.textContent = 
          (gameState.currentPlayer === BLACK ? '黒' : '白') + 'の手番です';
        statusDisplayElement.className = 'px-3 py-1 rounded bg-gray-100 text-gray-700 font-medium';
      }
    }
    
    // AIの手を打つ
    function makeAIMove() {
      if (gameState.gameOver) return;
      
      gameState.aiThinking = true;
      thinkingElement.classList.remove('hidden');
      thinkDepthElement.classList.remove('hidden');
      thinkingProgressElement.classList.remove('hidden');
      thinkDepthElement.textContent = "思考開始...";
      depthProgressElement.textContent = "探索準備中...";
      
      const player = gameState.currentPlayer;
      
      // 定石に従った手を優先
      if (gameState.openingUsed && 
          gameState.openingMoveIndex < gameState.openingUsed.seq.length) {
        const [nextY, nextX] = gameState.openingUsed.seq[gameState.openingMoveIndex];
        
        // 定石の手が有効か確認
        if (isValidMove(gameState.board, nextX, nextY, player)) {
          // 少し遅延させて思考アニメーションを見せる
          setTimeout(() => {
            makeMove(nextX, nextY);
            updateDebugInfo(`定石に従った手: ${String.fromCharCode(97 + nextX)}${nextY + 1}`);
            thinkingElement.classList.add('hidden');
            thinkDepthElement.classList.add('hidden');
            thinkingProgressElement.classList.add('hidden');
            gameState.aiThinking = false;
          }, 800);
          return;
        } else {
          // 定石の手が無効な場合は定石から外れる
          updateOpeningInfo("定石不適合 - 別の手を選択");
          gameState.openingUsed = null;
        }
      }
      
      // 角が取れる場合は最優先で取る
      const validMoves = getValidMoves(gameState.board, player);
      const cornerMove = validMoves.find(move => 
        (move.x === 0 || move.x === 7) && (move.y === 0 || move.y === 7)
      );
      
      if (cornerMove) {
        // 少し遅延させて思考アニメーションを見せる
        setTimeout(() => {
          makeMove(cornerMove.x, cornerMove.y);
          updateDebugInfo(`角を獲得: ${String.fromCharCode(97 + cornerMove.x)}${cornerMove.y + 1}`);
          thinkingElement.classList.add('hidden');
          thinkDepthElement.classList.add('hidden');
          thinkingProgressElement.classList.add('hidden');
          gameState.aiThinking = false;
        }, 800);
        return;
      }
      
      // 空きマス数をカウント
      const counts = countDiscs(gameState.board);
      const emptyCount = 64 - counts.black - counts.white;
      
      // AIレベルと現在のフェーズに基づいて探索深度を調整
      let depth = 4;  // デフォルト
      
      // AIレベルによる調整
      switch (gameState.aiLevel) {
        case 1: // 初級
          if (emptyCount < 10) depth = 6;
          else if (emptyCount < 20) depth = 4;
          else depth = 3;
          break;
        case 2: // 中級
          if (emptyCount < 10) depth = 8;
          else if (emptyCount < 20) depth = 5;
          else depth = 4;
          break;
        case 3: // 最強
          if (emptyCount < 10) depth = 10;
          else if (emptyCount < 15) depth = 8;
          else if (emptyCount < 25) depth = 6;
          else depth = 5;
          break;
        case 4: // グランドマスター
          if (emptyCount < 8) depth = 16;
          else if (emptyCount < 12) depth = 14;
          else if (emptyCount < 16) depth = 12;
          else if (emptyCount < 20) depth = 10;
          else if (emptyCount < 30) depth = 8;
          else depth = 6;
          break;
      }
      
      // 有効な手がない場合はパス
      if (validMoves.length === 0) {
        setTimeout(() => {
          switchPlayer();
          updateStatus();
          thinkingElement.classList.add('hidden');
          thinkDepthElement.classList.add('hidden');
          thinkingProgressElement.classList.add('hidden');
          gameState.aiThinking = false;
          updateStrategyAnalysis("AIは有効な手がないためパスしました。");
        }, 500);
        return;
      }
      
      if (gameState.usingWebWorker) {
        // WebWorkerを使った並列処理版
        gameState.worker.postMessage({
          board: gameState.board,
          player: player,
          depth: depth,
          alpha: -Infinity,
          beta: Infinity,
          timeLimit: gameState.aiTimeLimit
        });
      } else {
        // WebWorkerが使えない場合のメインスレッド処理版
        // 少し遅延させて思考アニメーションを見せる
        setTimeout(() => {
          // MTD(f)アルゴリズム
          const startTime = Date.now();
          const timeLimit = startTime + gameState.aiTimeLimit;
          
          // 反復深化探索
          let bestMove = null;
          let bestScore = -Infinity;
          let currentDepth = 1;
          
          try {
            // 最低限の深さから始めて徐々に深くする
            while (currentDepth <= depth && Date.now() < timeLimit) {
              gameState.currentThinkingDepth = currentDepth;
              thinkDepthElement.textContent = `深度: ${currentDepth}`;
              depthProgressElement.textContent = `${currentDepth}手先読み中`;
              
              // MTD(f)アルゴリズムで探索
              const result = mtdf(gameState.board, currentDepth, bestScore, player, timeLimit);
              
              // タイムアウトチェック
              if (result.timeOut) {
                updateDebugInfo(`深さ${currentDepth}でタイムアウト`);
                break;
              }
              
              bestScore = result.value;
              bestMove = result.move;
              
              // 上位の手を記録
              if (result.allMoves && result.allMoves.length > 0) {
                gameState.bestMoves = result.allMoves.sort((a, b) => b.value - a.value).slice(0, 3);
                displayBestMoves(gameState.bestMoves);
              }
              
              // 次の深度へ
              currentDepth++;
            }
            
            // 勝率予測の更新
            updateWinProbability(bestScore);
            
            // 最善手を実行
            if (bestMove) {
              makeMove(bestMove.x, bestMove.y);
              updateDebugInfo(`AI思考時間: ${Date.now() - startTime}ms, 深さ: ${currentDepth - 1}, 評価: ${bestScore}`);
            } else {
              // フォールバック: 単純な評価関数で最善手を選択
              let fallbackBestMove = null;
              let fallbackBestScore = -Infinity;
              
              for (const move of validMoves) {
                const nextBoard = cloneBoard(gameState.board);
                nextBoard[move.y][move.x] = player;
                
                const flipped = getFlippedPositions(gameState.board, move.x, move.y, player);
                for (const [fy, fx] of flipped) {
                  nextBoard[fy][fx] = player;
                }
                
                const score = evaluateBoard(nextBoard, player);
                
                if (score > fallbackBestScore) {
                  fallbackBestScore = score;
                  fallbackBestMove = move;
                }
              }
              
              if (fallbackBestMove) {
                makeMove(fallbackBestMove.x, fallbackBestMove.y);
                updateDebugInfo(`フォールバック手: ${String.fromCharCode(97 + fallbackBestMove.x)}${fallbackBestMove.y + 1}`);
              }
            }
          } catch (e) {
            console.error("AI思考エラー:", e);
            updateDebugInfo("AI思考エラー: " + e.message);
            
            // エラー時は単純な戦略で手を選択
            const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
            makeMove(randomMove.x, randomMove.y);
          }
          
          thinkingElement.classList.add('hidden');
          thinkDepthElement.classList.add('hidden');
          thinkingProgressElement.classList.add('hidden');
          gameState.aiThinking = false;
        }, 100);
      }
    }
    
    // MTD(f)アルゴリズム
    function mtdf(board, depth, firstGuess, player, timeLimit) {
      let g = firstGuess;
      let upperBound = Infinity;
      let lowerBound = -Infinity;
      let beta;
      
      // 探索の開始時間
      const startTime = Date.now();
      
      // 全ての手の評価値を保存する配列
      let allMoves = [];
      
      while (lowerBound < upperBound) {
        // 時間制限チェック
        if (Date.now() > timeLimit) {
          return { timeOut: true };
        }
        
        beta = Math.max(g, lowerBound + 1);
        
        // 0ウィンドウ探索
        const result = negamax(board, depth, beta - 1, beta, player, player, timeLimit, true);
        
        // タイムアウトチェック
        if (result.timeOut) {
          return { timeOut: true, value: g, move: result.move, allMoves };
        }
        
        g = result.value;
        
        if (g < beta) {
          upperBound = g;
        } else {
          lowerBound = g;
        }
        
        // 全ての手の評価を更新
        if (result.allMoves) {
          allMoves = result.allMoves;
        }
      }
      
      return {
        value: g,
        move: result.move,
        allMoves,
        timeOut: false
      };
    }
    
    // Negamax（アルファベータ法）
    function negamax(board, depth, alpha, beta, player, maximizingPlayer, timeLimit, topLevel = false) {
      // 時間制限チェック
      if (Date.now() > timeLimit) {
        return { timeOut: true };
      }
      
      // トランスポジションテーブル検索
      const ttResult = gameState.ttable.lookup(board, player, depth, alpha, beta);
      if (ttResult.found) {
        return {
          value: ttResult.value,
          move: ttResult.bestMove,
          timeOut: false
        };
      }
      
      // 終了条件
      if (depth === 0) {
        const value = evaluateBoard(board, maximizingPlayer);
        return { value, timeOut: false };
      }
      
      const opponent = player === BLACK ? WHITE : BLACK;
      const validMoves = getValidMoves(board, player);
      
      // 有効な手がない場合
      if (validMoves.length === 0) {
        // 相手も手がない場合は終局
        if (getValidMoves(board, opponent).length === 0) {
          // 石差で評価
          const counts = countDiscs(board);
          const playerStones = maximizingPlayer === BLACK ? counts.black : counts.white;
          const opponentStones = maximizingPlayer === BLACK ? counts.white : counts.black;
          
          const value = (playerStones > opponentStones) ? 10000 : 
                        (playerStones < opponentStones) ? -10000 : 0;
          
          return { value, timeOut: false };
        }
        
        // パスの場合は相手番
        const result = negamax(board, depth - 1, -beta, -alpha, opponent, maximizingPlayer, timeLimit);
        return {
          value: -result.value,
          timeOut: result.timeOut
        };
      }
      
      // 角を優先するソート
      validMoves.sort((a, b) => {
        const aIsCorner = (a.x === 0 || a.x === 7) && (a.y === 0 || a.y === 7);
        const bIsCorner = (b.x === 0 || b.x === 7) && (b.y === 0 || b.y === 7);
        
        if (aIsCorner && !bIsCorner) return -1;
        if (!aIsCorner && bIsCorner) return 1;
        
        return 0;
      });
      
      let bestValue = -Infinity;
      let bestMove = null;
      let allMoves = [];
      let flag = 2; // 上限値として初期化
      
      for (const move of validMoves) {
        // 時間制限チェック
        if (Date.now() > timeLimit) {
          return { timeOut: true, value: bestValue, move: bestMove };
        }
        
        // 次の盤面を生成
        const nextBoard = cloneBoard(board);
        nextBoard[move.y][move.x] = player;
        
        // 挟まれた石を裏返す
        const flipped = getFlippedPositions(board, move.x, move.y, player);
        for (const [fy, fx] of flipped) {
          nextBoard[fy][fx] = player;
        }
        
        // 再帰的に評価
        const result = negamax(nextBoard, depth - 1, -beta, -alpha, opponent, maximizingPlayer, timeLimit);
        
        // タイムアウトチェック
        if (result.timeOut) {
          return { timeOut: true, value: bestValue, move: bestMove };
        }
        
        const value = -result.value;
        
        // トップレベルノードではすべての手の評価値を記録
        if (topLevel) {
          allMoves.push({
            x: move.x,
            y: move.y,
            value: value
          });
        }
        
        if (value > bestValue) {
          bestValue = value;
          bestMove = move;
          
          if (value > alpha) {
            alpha = value;
            flag = 0; // 精確な値
            
            if (alpha >= beta) {
              flag = 1; // 下限値
              break;
            }
          }
        }
      }
      
      // トランスポジションテーブルに結果を格納
      gameState.ttable.store(board, player, depth, bestValue, flag, bestMove);
      
      return {
        value: bestValue,
        move: bestMove,
        allMoves: allMoves,
        timeOut: false
      };
    }
    
    // 盤面評価関数（高度版）
    function evaluateBoard(board, maximizingPlayer) {
      const player = maximizingPlayer;
      const opponent = player === BLACK ? WHITE : BLACK;
      
      // 各評価項目のスコア初期化
      let mobilityScore = 0;
      let positionalScore = 0;
      let cornerScore = 0;
      let stabilityScore = 0;
      let parityScore = 0;
      let patternScore = 0;
      
      // 0. パターン認識評価
      const patternResult = gameState.patternRecognizer.matchPatterns(board, player);
      patternScore = patternResult.value;
      
      // 1. 着手可能場所数（モビリティ）評価
      const playerMoves = getValidMoves(board, player).length;
      const opponentMoves = getValidMoves(board, opponent).length;
      mobilityScore = playerMoves - opponentMoves;
      
      // 2. マス位置評価（角の所有状況に応じて動的に評価を調整）
      // 角の状態をチェック
      const cornerStates = {
        topLeft: board[0][0],
        topRight: board[0][7],
        bottomLeft: board[7][0],
        bottomRight: board[7][7]
      };
      
      // 角が埋まっている場合、隣接するX-スクエアの評価を調整
      const adjustedWeights = JSON.parse(JSON.stringify(POSITION_WEIGHTS)); // ディープコピー
      
      // 左上角の調整
      if (cornerStates.topLeft === player) {
        adjustedWeights[0][1] = 50; // C-スクエアが安全に
        adjustedWeights[1][0] = 50;
        adjustedWeights[1][1] = 30; // X-スクエアも安全に
      }
      
      // 右上角の調整
      if (cornerStates.topRight === player) {
        adjustedWeights[0][6] = 50;
        adjustedWeights[1][7] = 50;
        adjustedWeights[1][6] = 30;
      }
      
      // 左下角の調整
      if (cornerStates.bottomLeft === player) {
        adjustedWeights[7][1] = 50;
        adjustedWeights[6][0] = 50;
        adjustedWeights[6][1] = 30;
      }
      
      // 右下角の調整
      if (cornerStates.bottomRight === player) {
        adjustedWeights[7][6] = 50;
        adjustedWeights[6][7] = 50;
        adjustedWeights[6][6] = 30;
      }
      
      // 調整された重みで評価
      for (let y = 0; y < BOARD_SIZE; y++) {
        for (let x = 0; x < BOARD_SIZE; x++) {
          if (board[y][x] === player) {
            positionalScore += adjustedWeights[y][x];
          } else if (board[y][x] === opponent) {
            positionalScore -= adjustedWeights[y][x];
          }
        }
      }
      
      // 3. 角の評価（特に重要）
      for (const [y, x] of CORNER_POSITIONS) {
        if (board[y][x] === player) {
          cornerScore += CORNER_VALUE;
        } else if (board[y][x] === opponent) {
          cornerScore -= CORNER_VALUE;
        }
      }
      
      // 4. 安定石の評価（高度バージョン）
      const stableDiscs = countStableDiscs(board);
      stabilityScore = (stableDiscs[player] - stableDiscs[opponent]) * 50;
      
      // 5. パリティ評価（終盤に重要）
      const { black, white } = countDiscs(board);
      const emptyCount = 64 - black - white;
      
      if (emptyCount <= 16) { // 終盤ではパリティが重要
        if (emptyCount % 2 === 0) { // 偶数なら後手有利
          parityScore = player === WHITE ? 65 : -65;
        } else { // 奇数なら先手有利
          parityScore = player === BLACK ? 65 : -65;
        }
      }
      
      // 石差の評価（終盤に重要）
      const discDiff = player === BLACK ? (black - white) : (white - black);
      
      // ゲームフェーズに応じた重み付け
      let finalScore = 0;
      
      if (emptyCount > 40) { // 序盤
        finalScore = 
          positionalScore * 1.0 +
          mobilityScore * 5.0 +
          cornerScore * 35.0 +
          stabilityScore * 1.0 +
          patternScore * 1.0;
      } else if (emptyCount > 20) { // 中盤
        finalScore = 
          positionalScore * 1.0 +
          mobilityScore * 3.0 +
          cornerScore * 25.0 +
          stabilityScore * 2.0 +
          discDiff * 1.0 +
          patternScore * 0.8;
      } else if (emptyCount > 10) { // 終盤序盤
        finalScore = 
          positionalScore * 0.5 +
          mobilityScore * 2.0 +
          cornerScore * 15.0 +
          stabilityScore * 5.0 +
          discDiff * 5.0 +
          parityScore * 2.0;
      } else { // 終盤
        finalScore = 
          cornerScore * 10.0 +
          stabilityScore * 10.0 +
          discDiff * 10.0 +
          parityScore * 5.0;
      }
      
      return finalScore;
    }
    
    // 安定した石の数をカウント（高度なバージョン）
    function countStableDiscs(board) {
      const stableDiscs = {};
      stableDiscs[BLACK] = 0;
      stableDiscs[WHITE] = 0;
      
      // 安定石のチェック
      const stable = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(false));
      
      // 1. まず角は常に安定
      for (const [y, x] of CORNER_POSITIONS) {
        if (board[y][x] !== EMPTY) {
          stable[y][x] = true;
          stableDiscs[board[y][x]]++;
        }
      }
      
      // 2. 安定石に隣接する同色の石で、反対方向からひっくり返される可能性がない石も安定
      let changed;
      do {
        changed = false;
        
        for (let y = 0; y < BOARD_SIZE; y++) {
          for (let x = 0; x < BOARD_SIZE; x++) {
            if (board[y][x] !== EMPTY && !stable[y][x]) {
              // 既に安定していない場合のみチェック
              
              // 全方向からの安定性を確認
              let isStable = true;
              
              // 水平方向 (左右)
              if (x > 0 && x < BOARD_SIZE - 1) {
                if (!(stable[y][x-1] && board[y][x-1] === board[y][x]) && 
                    !(stable[y][x+1] && board[y][x+1] === board[y][x])) {
                  isStable = false;
                }
              } else if (x === 0) {
                if (!(stable[y][x+1] && board[y][x+1] === board[y][x])) {
                  isStable = false;
                }
              } else { // x === BOARD_SIZE - 1
                if (!(stable[y][x-1] && board[y][x-1] === board[y][x])) {
                  isStable = false;
                }
              }
              
              // 垂直方向 (上下)
              if (y > 0 && y < BOARD_SIZE - 1) {
                if (!(stable[y-1][x] && board[y-1][x] === board[y][x]) && 
                    !(stable[y+1][x] && board[y+1][x] === board[y][x])) {
                  isStable = false;
                }
              } else if (y === 0) {
                if (!(stable[y+1][x] && board[y+1][x] === board[y][x])) {
                  isStable = false;
                }
              } else { // y === BOARD_SIZE - 1
                if (!(stable[y-1][x] && board[y-1][x] === board[y][x])) {
                  isStable = false;
                }
              }
              
              // 対角線方向 (右下-左上)
              if (x > 0 && y > 0 && x < BOARD_SIZE - 1 && y < BOARD_SIZE - 1) {
                if (!(stable[y-1][x-1] && board[y-1][x-1] === board[y][x]) && 
                    !(stable[y+1][x+1] && board[y+1][x+1] === board[y][x])) {
                  isStable = false;
                }
              }
              
              // 対角線方向 (右上-左下)
              if (x > 0 && y < BOARD_SIZE - 1 && x < BOARD_SIZE - 1 && y > 0) {
                if (!(stable[y+1][x-1] && board[y+1][x-1] === board[y][x]) && 
                    !(stable[y-1][x+1] && board[y-1][x+1] === board[y][x])) {
                  isStable = false;
                }
              }
              
              // この石が安定している場合、カウントを更新
              if (isStable) {
                stable[y][x] = true;
                stableDiscs[board[y][x]]++;
                changed = true;
              }
            }
          }
        }
      } while (changed);
      
      return stableDiscs;
    }
    
    // イベントリスナーの設定
    function setupEventListeners() {
      newGameButton.addEventListener('click', newGame);
      
      playerColorSelect.addEventListener('change', () => {
        newGame();
      });
      
      aiLevelSelect.addEventListener('change', () => {
        const level = parseInt(aiLevelSelect.value);
        gameState.aiLevel = level;
        
        // レベル表示
        switch (level) {
          case 1:
            maxDepthElement.textContent = "6-8";
            break;
          case 2:
            maxDepthElement.textContent = "8-10";
            break;
          case 3:
            maxDepthElement.textContent = "10-12";
            break;
          case 4:
            maxDepthElement.textContent = "14-16";
            break;
        }
        
        updateDebugInfo(`AIレベルを変更: ${level}`);
      });
      
      thinkingTimeSelect.addEventListener('change', () => {
        const timeLimit = parseInt(thinkingTimeSelect.value);
        gameState.aiTimeLimit = timeLimit;
        updateDebugInfo(`思考時間を変更: ${timeLimit}ms`);
      });
      
      toggleDebugButton.addEventListener('click', () => {
        gameState.debugMode = !gameState.debugMode;
        if (gameState.debugMode) {
          debugInfoElement.classList.remove('hidden');
          toggleDebugButton.textContent = "デバッグ情報を隠す";
        } else {
          debugInfoElement.classList.add('hidden');
          toggleDebugButton.textContent = "デバッグ情報を表示";
        }
      });
    }
    
    // ゲーム開始
    function init() {
      // トランスポジションテーブルサイズ表示
      tableSizeElement.textContent = `2^22`;
      
      // 定石数表示
      openingCountElement.textContent = `${OPENINGS.length}+`;
      
      // 探索深度表示
      maxDepthElement.textContent = "14-16";
      
      // WebWorkerの初期化
      initializeWebWorker();
      
      setupEventListeners();
      newGame();
    }
    
    // 初期化実行
    init();
  </script>
</body>
</html>
